/*
 * Public DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.2
 *
 * SOFTWARE RIGHTS
 *
 * This file is a part of the ANTLR-based C++ grammar and is free
 * software.  We do not reserve any LEGAL rights to its use or
 * distribution, but you may NOT claim ownership or authorship of this
 * grammar or support code.  An individual or company may otherwise do
 * whatever they wish with the grammar distributed herewith including the
 * incorporation of the grammar or the output generated by ANTLR into
 * commerical software.  You may redistribute in source or binary form
 * without payment of royalties to us as long as this header remains
 * in all source distributions.
 *
 * We encourage users to develop parsers/tools using this grammar.
 * In return, we ask that credit is given to us for developing this
 * grammar.  By "credit", we mean that if you incorporate our grammar or
 * the generated code into one of your programs (commercial product,
 * research project, or otherwise) that you acknowledge this fact in the
 * documentation, research report, etc....  In addition, you should say nice
 * things about us at every opportunity.
 *
 * As long as these guidelines are kept, we expect to continue enhancing
 * this grammar.  Feel free to send us enhancements, fixes, bug reports,
 * suggestions, or general words of encouragement at parrt@parr-research.com.
 * 
 * NeXT Computer Inc.
 * 900 Chesapeake Dr.
 * Redwood City, CA 94555
 * 12/02/1994
 * 
 * Restructured for public consumption by Terence Parr late February, 1995.
 *
 * DISCLAIMER: we make no guarantees that this grammar works, makes sense,
 *             or can be used to do anything useful.
 */
/* 2001-2002
 * Version 1.0
 * This C++ grammar file has been converted from PCCTS to run under 
 *  ANTLR to generate lexer and parser in C++ code by
 *  Jianguo Zuo and David Wigg at
 *  The Centre for Systems and Software Engineering
 *  London South Bank University
 *  London, UK.
 *
 */
/* 2003
 * Version 2.0 was published by David Wigg in September 2003
 */
/* 2004
 * Version 3.0 July 2004
 * This is version 3.0 of the C++ grammar definition for ANTLR to 
 *  generate lexer and parser in C++ code updated by
 *  David Wigg at
 *  The Centre for Systems and Software Engineering
 *  London South Bank University
 *  London, UK.
 */
/* 2005
 * Version 3.1 November 2005
 * Updated by David Wigg at London South Bank University
 *
 */
/* 2007
 * Version 3.2 November 2007
 * Updated by David Wigg at London South Bank University
 *
 * wiggjd@bcs.ac.uk
 * blackse@lsbu.ac.uk
 *
 * See MyReadMe.txt for further information
 *
 * This file is best viewed in courier font with tabs set to 4 spaces
 */
 
 


/* -- 2010 --
 * Version 4.0.1 August 2010
 * Modified and reworked to compile with ANTLR 3.2
 *  by Ramin Zaghi
 * 
 * Please note that this is the first public release
 *  for ANTLR 3.2; This does not comiple with any older
 *  versions of ANTLR. This may also have some missing 
 *  features compared to the 2007 update by David Wigg.
 *  I am publishing this work only to make this first
 *  ANTLR 3.2 update  available  to  the  community
 *  however if you are interested in a more complete 
 *  work please take a look at David's 2007 update.
 * 
 *  I emphasize that this new update needs more work
 *  and can be restructured to make it more developer
 *  friendly. The project file is a MSVS2008 project
 *  file and it only includes a "Debug" configuration.
 *  
 *  You may send your comments to < antlr3_cpp_parser@taggedprogramming.com >
 *  
 */






grammar CPP;

options {  
    //backtrack = true;
    //memoize = true;
    language = Java;
    //k = 2;
    output = AST;
    ASTLabelType = IterableTree;
}


@parser::header {
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright (c) 2012, Robin Jarry, All rights reserved.               *
 *                                                                     *
 * This file is part of APIWATCH and published under the BSD license.  *
 *                                                                     *
 * See the "LICENSE" file for more information.                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
package org.apiwatch.analyser.cpp;
 
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apiwatch.util.antlr.IterableTree;
import org.apiwatch.analyser.cpp.Header;
import org.apiwatch.analyser.cpp.CPPSymbols;
import org.apiwatch.analyser.cpp.ParserConstants.FunctionParserState;
import org.apiwatch.analyser.cpp.ParserConstants.FunctionSpecifier;
import org.apiwatch.analyser.cpp.ParserConstants.QualifiedItem;
import org.apiwatch.analyser.cpp.ParserConstants.StorageClass;
import org.apiwatch.analyser.cpp.ParserConstants.TypeQualifier;
import org.apiwatch.analyser.cpp.ParserConstants.TypeSpecifier;
}

@parser::members {

int statementTrace = 2;
CPPParser__ _p;

List<Header> headers;

// special constructor
public CPPParser(TokenStream input, List<Header> headers) {
    this(input, new RecognizerSharedState());
    this.headers = headers;
}

void parserInit() {
    _p = new CPPParser__(input, 2);
}

void _debug(String msg, Object... params) {
    if (statementTrace >= 1) {
        msg = input.LT(1).getLine() + ": " + msg + "\n";
		    System.out.printf(msg, params);
    }
}

}

@lexer::header {
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright (c) 2012, Robin Jarry, All rights reserved.               *
 *                                                                     *
 * This file is part of APIWATCH and published under the BSD license.  *
 *                                                                     *
 * See the "LICENSE" file for more information.                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
package org.apiwatch.analyser.cpp;
 
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apiwatch.analyser.cpp.Header;

}

@lexer::members {
public List<String> systemPaths;
public List<Header> headers; 
private static final Pattern PREPROC_LINE = Pattern.compile("#\\s*(\\d+)\\s*\"(.+?)\"");

// special constructor
public CPPLexer(CharStream input, List<String> systemPaths) {
    this(input, new RecognizerSharedState());
    this.systemPaths = systemPaths != null ? systemPaths : new ArrayList<String>();
    this.headers = new ArrayList<Header>();
}

private void recordHeader(int line, String text) {
    text = text.replace("\\\\", "\\"); // for windows paths
    Matcher match = PREPROC_LINE.matcher(text);
    if (match.find()) {
        int sourceLine = Integer.valueOf(match.group(1));
        String sourceFile = match.group(2);
        boolean isSystemHeader = false;
        // ignore case and file path separator.
        String source = sourceFile.toLowerCase().replace("\\", "/");
        for (String path : systemPaths) {
            if (source.startsWith(path.replace("\\", "/").toLowerCase())) {
                isSystemHeader = true;
                break;
            }
        }
        headers.add(new Header(line, isSystemHeader, sourceLine, sourceFile));
    }
}

}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////  GENERAL RULES ////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

translation_unit
@init {
    parserInit();
}
  : {_p.enterExternalScope();}
    external_declaration*  EOF
    {_p.exitExternalScope();}
  ;



external_declaration  
@init {
   _p.lineNo = input.LT(1).getLine();
   _p.KandR = false;
   _p.functionSpecifier = FunctionSpecifier.Invalid;  // FunctionSpecifier : inline,virtual,explicit
}
  :
    // Template explicit specialisation
    (Template LessThan GreaterThan)=>
    {_debug("external_declaration template explicit-specialisation");}
    Template LessThan GreaterThan external_declaration

  |
    // All typedefs
    (TypeDef)=>
    (
      (TypeDef Enum)=>
      {_debug("external_declaration Typedef enum type");}
      TypeDef enum_specifier {_p.typeDef = true;} init_declarator_list? SemiColon 
    |
      (declaration_specifiers function_declarator[false] SemiColon)=>  // DW 11/02/05 This may not be possible
      {_debug("external_declaration Typedef function type");}
      declaration
    |
      (declaration_specifiers init_declarator_list? SemiColon)=>
      {_debug("external_declaration Typedef variable type");}
      declaration
    |
      (TypeDef class_specifier)=>
      {_debug("external_declaration Typedef class type");}
      TypeDef class_decl_or_def {_p.typeDef = true;} init_declarator_list? SemiColon 
    )
    
  |  
    // Class template declaration or definition
    (template_head function_specifier* class_specifier)=>
    {_debug("external_declaration Templated class decl or def");}
    template_head 
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})* 
    class_decl_or_def 
    init_declarator_list? 
    SemiColon   // declaration
  |
    // Templated functions and constructors matched here.
    {_p.beginTemplateDeclaration();}
    template_head
    (  
      // templated forward class decl, init/decl of static member in template
      (declaration_specifiers (init_declarator_list)? SemiColon )=>
      {_debug("external_declaration Templated class forward declaration");}
      declaration_specifiers (init_declarator_list)? SemiColon 
    |  
      // Templated function declaration
      (declaration_specifiers function_declarator[false] SemiColon)=> 
      {_debug("external_declaration Templated function declaration");}
      declaration
    |  
      // Templated function definition
      (declaration_specifiers function_declarator[true] LCurly)=> 
      {_debug("external_declaration Templated function definition");}
      function_definition
    |
      // Templated constructor definition
                // JEL 4/3/96 Added predicate that works once the
                // restriction is added that ctor cannot be virtual
      (ctor_decl_spec {_p.itemIs(QualifiedItem.Ctor)}?)=>
      {_debug("external_declaration Templated constructor definition");}
      ctor_definition
    )
    {_p.endTemplateDeclaration();}
  |  
    // Enum definition (don't want to backtrack over this in other alts)
    (Enum ID? LCurly)=>
    {_debug("external_declaration Enum definition");}
    enum_specifier init_declarator_list? SemiColon 
  |
    // Destructor definition (templated or non-templated)
    (template_head? dtor_head[true] LCurly)=>
    {_debug("external_declaration Destructor definition");}
    template_head? dtor_head[true] dtor_body
  |  
    // Constructor definition (non-templated)
    // JEL 4/3/96 Added predicate that works, once the
    // restriction is added that ctor cannot be virtual
    // and ctor_declarator uses a more restrictive id
    ( ctor_decl_spec?  {_p.itemIs(QualifiedItem.Ctor)}?)=>
    {_debug("external_declaration Constructor definition");}
    ctor_definition
  |  
    // User-defined type cast
    ((Inline)? scope_override  conversion_function_decl_or_def)=>
    {_debug("external_declaration Operator function");}
    (Inline)? s = scope_override conversion_function_decl_or_def 
  |   
    // Function declaration
    (declaration_specifiers function_declarator[false] SemiColon)=> 
    {_debug("external_declaration Function declaration");}
    declaration_specifiers function_declarator[false] SemiColon 
  |
    // Function definition
    (declaration_specifiers  function_declarator[true] LCurly)=> 
    {_debug("external_declaration Function definition");}
    function_definition
  |
    // Function definition with int return assumed
    (function_declarator[true] LCurly)=> 
    {_debug("external_declaration Function definition without return type");}
    function_definition
  |
    // K & R Function definition
    (declaration_specifiers  function_declarator[true] declaration)=>
    {_p.KandR = true;
     _debug("external_declaration K & R function definition");}
    function_definition
  |
    // K & R Function definition with int return assumed
    (function_declarator[true] declaration)=>
    {_p.KandR = true;
     _debug("external_declaration K & R function definition without return type");}
    function_definition
  |
    // Class declaration or definition
    (Extern? function_specifier* class_specifier)=>
    {_debug("external_declaration Class decl or def");}
    (Extern)? 
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})*  
    class_decl_or_def 
    init_declarator_list? 
    SemiColon 

  |
    // Copied from member_declaration 31/05/07
    (declaration_specifiers init_declarator_list? SemiColon)=>
    {_debug("external_declaration Declaration");}
    declaration

  |  
    // Namespace definition
    {_debug("external_declaration Namespace definition");}
    Namespace namespace_definition
  |  
    // Semicolon
    {_debug("external_declaration Semicolon");}
    SemiColon 
  |  
    // Anything else 
    {_debug("external_declaration Other Declaration");}
    declaration
  ;
/**
  |  
    // The next two entries may be used for debugging
    // Use this statement in the source code to turn antlr trace on (See note above)
    'antlrTrace_on' {antlrTrace(True);}
  |
    // Use this statement in the source code to turn antlr trace off (See note above)
    'antlrTrace_off' {antlrTrace(False);}

  )
  ;
**/

member_declaration
@init {
    _p.lineNo = input.LT(1).getLine();
}
  :
    // Template explicit specialisation
    (Template LessThan GreaterThan)=>
    {_debug("member_declaration Template explicit-specialisation");}
    Template LessThan GreaterThan member_declaration
  |
    // All typedefs
    (TypeDef)=>
    (
      (TypeDef Enum)=>
      {_debug("member_declaration Typedef enum type");}
      TypeDef enum_specifier {_p.typeDef = true;} (init_declarator_list)? SemiColon 
    |
      (declaration_specifiers function_declarator[false] SemiColon)=>  // DW 11/02/05 This may not be possible member declaration
      {_debug("member_declaration Typedef function type");}
      declaration
    |
      (declaration_specifiers init_declarator_list? SemiColon)=>
      {_debug("member_declaration Typedef variable type");}
      declaration
    |
      (TypeDef class_specifier)=>
      {_debug("member_declaration Typedef class type");}
      TypeDef class_decl_or_def {_p.typeDef = true;} init_declarator_list? SemiColon 
    )
    
  |
    // Function declaration
    (declaration_specifiers  function_declarator[false] SemiColon)=>
    {_debug("member_declaration Function declaration");}
    declaration_specifiers function_declarator[false] SemiColon 
  
  |  
    // Function definition
    (declaration_specifiers function_declarator[true] LCurly)=>
    {_debug("member_declaration Function definition");}
    function_definition

  |
    // Class declaration or definition
    ((Friend)? function_specifier* class_specifier)=>
    {_debug("member_declaration Class decl or def");}
    Friend? 
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})* 
    class_decl_or_def 
    init_declarator_list? 
    SemiColon 
  | 
    (declaration_specifiers init_declarator_list? SemiColon)=>
    {_debug("member_declaration Declaration");}
    declaration
  |
    // Member without a type (I guess it can only be a function declaration or definition)
    (function_specifier* function_declarator[false] SemiColon)=>
    {_debug("warning Function declaration found without return type");
     _debug("member_declaration Function declaration");}
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})* 
    function_declarator[false] 
    SemiColon 
  |
    // Member without a type (I guess it can only be a function definition)
    (function_specifier* function_declarator[true] LCurly)=>
    {_debug("warning Function definition found without return type");
     _debug("member_declaration Function definition without return type");}
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})* 
    function_declarator[true] 
    compound_statement 
    {_p.endFunctionDefinition();}
  |
    // Templated class declaration or definition
    (template_head function_specifier* class_specifier)=>
    {_debug("member_declaration Templated class decl or def");}
    template_head 
    (fs=function_specifier {_p.functionSpecifier = $fs.val;})* 
    class_decl_or_def 
    init_declarator_list? 
    SemiColon   // declaration
  |  
    // Enum definition (don't want to backtrack over this in other alts)
    (Enum ID? LCurly)=>
    {_debug("member_declaration Enum definition");}
    enum_specifier init_declarator_list? SemiColon  
  |
    // Constructor declarator
    ( ctor_decl_spec {_p.itemIs(QualifiedItem.Ctor)}? ctor_declarator[false] SemiColon)=>
    {_debug("member_declaration Constructor declarator");}
    ctor_decl_spec ctor_declarator[false] SemiColon 
  |  
    // JEL Predicate to distinguish ctor from function
    // This works now that ctor cannot have Virtual
    // It unfortunately matches A::A where A is not enclosing
    // class -- this will have to be checked semantically
    // Constructor definition
    (  ctor_decl_spec
      {_p.itemIs(QualifiedItem.Ctor)}?
      ctor_declarator[true]
      (Colon        // DEFINITION :ctor_initializer
      |LCurly       // DEFINITION (compound Statement) ?
      )
    )=>
    {_debug("member_declaration Constructor definition");}
    ctor_definition 
  |  
    // No template_head allowed for dtor member
    // Backtrack if not a dtor (no Tilde)
    // Destructor declaration
    (dtor_head[false] SemiColon)=>
    {_debug("member_declaration Destructor declaration");}
    dtor_head[false] SemiColon 
  |
    // No template_head allowed for dtor member
    // Backtrack if not a dtor (no Tilde)
    // Destructor definition
    (dtor_head[true] LCurly)=>
    {_debug("member_declaration Destructor definition");}
    dtor_head[true] dtor_body
  |  
    // User-defined type cast
    (Inline? conversion_function_decl_or_def)=>
    {_debug("member_declaration Operator function");}
    Inline? conversion_function_decl_or_def
  |  
    // Hack to handle decls like "superclass::member",
    // to redefine access to private base class public members
    // Qualified identifier
    (qualified_id SemiColon)=>
    {_debug("member_declaration Qualified ID");}
    qualified_id SemiColon 
  |
    // Access specifier  
    {_debug("member_declaration Access specifier");}
    access_specifier Colon
  |
    SemiColon 
  ;
  
/**
  |  
    // The next two entries may be used for debugging
    // Use this statement in the source code to turn antlr trace on (See note above)
    'antlrTrace_on' {antlrTrace(True);}
  |
    // Use this statement in the source code to turn antlr trace off (See note above)
    'antlrTrace_off' {antlrTrace(False);}
  )
  ;
  
 **/

namespace_definition
  : (ID {_p.declaratorID($ID.text, QualifiedItem.Type);} )?
    LCurly 
    {_p.enterNewLocalScope();}
    external_declaration*
    {_p.exitLocalScope();}
    RCurly
  ;

namespace_alias_definition
  : Namespace ID Assign qualified_id SemiColon {_p.declaratorID($ID.text, QualifiedItem.Type);} 
  ;

function_definition
@init {
    _p.lineNo = input.LT(1).getLine();
}
@after {
    _p.endFunctionDefinition();
}
  : {input.LA(1) != Scope && input.LA(1) != ID || _p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor)}? 
    declaration_specifiers function_declarator[true]
    (
      (declaration)=> 
      ({_p.lineNo = input.LT(1).getLine();} declaration)*  // Possible for K & R definition
      {_p.inParameterList = false;}
    )?
    compound_statement
  |  
    function_declarator[true]
    (
      (declaration)=>
      ({_p.lineNo = input.LT(1).getLine();} declaration)*  // Possible for K & R definition
      {_p.inParameterList = false;}
    )?
    compound_statement
  ;

declaration
  : (Extern StringLiteral)=> linkage_specification
  | simple_declaration
  | using_statement
  ;


linkage_specification
  : Extern StringLiteral (LCurly external_declaration* RCurly | declaration)
  ;

// Used only by predicates
class_head
  : (Struct|Union|Class)
    (ID  
      (LessThan template_argument_list GreaterThan)?
      base_clause? 
    )? 
    LCurly
  ;

declaration_specifiers
@init {
    // Locals
    boolean td = false;  // For typedef
    boolean fd = false;  // For friend
    int sc = StorageClass.Invalid;  // auto,register,static,extern,mutable
    int tq = TypeQualifier.Invalid;  // const,volatile  // aka cv_qualifier See type_qualifier
    int ts = TypeSpecifier.Invalid;  // char,int,double, etc., class,struct,union
    int fs = FunctionSpecifier.Invalid;  // inline,virtual,explicit

    // Global flags to allow for nested declarations
    _p.typeDef = td;
    _p.friend = fd;
    _p.storageClass = sc;
    _p.typeQualifier = tq;
    _p.typeSpecifier = ts;
    _p.functionSpecifier = fs;
}
  :
	  ( 
	    TypeDef                    {td = true;}      
	  | Friend                     {fd = true;}
	  | storage_class_specifier    {sc |= $storage_class_specifier.val;}
	  | tq1=type_qualifier         {tq |= $tq1.val;}
	  | function_specifier         {fs |= $function_specifier.val;}
	  | DeclSpec LParen ID RParen
	  )*
	  
	  type_specifier               {ts = $type_specifier.val;}
	  tq2=type_qualifier*          {tq |= $tq2.val;}
  
  {_p.typeDef = td; _p.declarationSpecifier(td, fd, sc, tq, ts, fs);}
  
  ;


storage_class_specifier returns [int val]
  : Auto        {$val = StorageClass.Auto;}
  | Register    {$val = StorageClass.Register;}
  | Static      {$val = StorageClass.Static;}
  | Extern      {$val = StorageClass.Extern;}
  | Mutable     {$val = StorageClass.Mutable;}
  ;


function_specifier returns [int val]
  : Inline      {$val = FunctionSpecifier.Inline;}
  | Virtual     {$val = FunctionSpecifier.Virtual;}
  | Explicit    {$val = FunctionSpecifier.Explicit;}
  ;


type_specifier returns [int val]
@init {
    $val = TypeSpecifier.Invalid; 
}
  : {_p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor)}? qualified_type
  | ( TypeName | Enum | class_specifier) q=qualified_type {_p.declaratorID($q.name, QualifiedItem.Type);}  // store typename in dictionary
  | ( builtin_type {$val |= $builtin_type.val;} )+
  ;

builtin_type returns [int val]
  : Void       {$val = TypeSpecifier.Void;}
  | Int        {$val = TypeSpecifier.Int;}
  | Long       {$val = TypeSpecifier.Long;}
  | Char       {$val = TypeSpecifier.Char;}
  | WChar_T    {$val = TypeSpecifier.WChar_T;}
  | Bool       {$val = TypeSpecifier.Bool;}
  | Short      {$val = TypeSpecifier.Short;}
  | Signed     {$val = TypeSpecifier.Signed;}
  | Unsigned   {$val = TypeSpecifier.Unsigned;}
  | Float      {$val = TypeSpecifier.Float;}
  | Double     {$val = TypeSpecifier.Double;}
  ;


//qualified_type
qualified_type returns [String name]
  : 
    // JEL 3/29/96 removed this predicate and moved it upwards to
    // type_specifier.  This was done to allow parsing of ~ID to 
    // be a unary_expression, which was never reached with this 
    // predicate on
    // 
    scope_override ID 
    (
      options {backtrack=true;}:
      LessThan 
      template_argument_list 
      GreaterThan
    )? 
    {$name=$ID.text;}
  ;

class_specifier returns [int val]
  : Class  {$val = TypeSpecifier.Class;} 
  | Struct {$val = TypeSpecifier.Struct;} 
  | Union  {$val = TypeSpecifier.Union;}  
  ;

// aka cv_qualifier
type_qualifier returns [int val] 
  : Const     {$val = TypeQualifier.Const;} 
  | Volatile  {$val = TypeQualifier.Volatile;}
  ;


class_decl_or_def
@init {
    String saveClass = _p.enclosingClass;
    int typeSpec = TypeSpecifier.Invalid;
}
  : class_specifier {typeSpec = $class_specifier.val;}
   
    (DeclSpec LParen expression RParen)*  // Temp for Evgeniy
    
    ( 
      id = qualified_id
      (
        (SemiColon|member_declarator)=> /* Empty (stop matching any more tokens) */
        {
          _p.classForwardDeclaration($id.name, typeSpec); // store class name in dictionary
        } 
      |
        (base_clause)?
        LCurly
        {
          saveClass = _p.enclosingClass; 
          _p.enclosingClass = "symbols->strdup(qid)"; 
          _p.beginClassDefinition($id.name, typeSpec); // This stores class name in dictionary
        }
        member_declaration*
        {
          _p.endClassDefinition();
        }
        RCurly
        {
          _p.enclosingClass = saveClass;
        }
      )
    |
      LCurly
      {
        saveClass = _p.enclosingClass; 
        _p.enclosingClass = "__anonymous";
        _p.beginClassDefinition("anonymous", typeSpec);  // This stores "anonymous" name in dictionary
      }
      member_declaration*
      {
        _p.endClassDefinition();
      }
      RCurly
      {
        _p.enclosingClass = saveClass;
      }
    )
  ;

base_clause
  : Colon base_specifier (Comma base_specifier)*
  ;

base_specifier
  : Virtual access_specifier? qualified_type 
  | access_specifier Virtual? qualified_type
  | qualified_type
  ;

access_specifier
  : Public
  | Protected
  | Private
  ;

enum_specifier
  : Enum
    (  
      LCurly enumerator_list RCurly
    |  
      qualified_id
      {_p.beginEnumDefinition($qualified_id.name);}  // This stores id name as an enum type in dictionary
      (LCurly enumerator_list RCurly)?
      {_p.endEnumDefinition();}
    )
  ;

enumerator_list
  : enumerator (Comma enumerator? )*  // Allows comma at end of list
  ;

enumerator
  : ID (Assign constant_expression)?
    {_p.enumElement($ID.text);}  // This stores id name in dictionary
  ;

// This matches a generic qualified identifier ::T::B::foo
// (including Operator).
// It might be a good idea to put T::~dtor in here
// as well, but id_expression in expr.g puts it in manually.
// Maybe not, 'cause many people use this assuming only A::B.
// How about a 'qualified_complex_id'?
qualified_id returns [String name]
@init {
    StringBuilder sb = new StringBuilder();
}
@after {
    $name = sb.toString();
}
  :  
    scope_override    {sb.append($scope_override.val);}
    ( 
      ID              {sb.append($ID.text);}
      ((LessThan template_argument_list GreaterThan)=>  LessThan template_argument_list GreaterThan)?
    |  
      Operator optor  {sb.append($Operator.text); sb.append($optor.text);}
    |
      Tilde id_expression    // 1/08/07
    )
  ;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////


typeID
  : {_p.isTypeName($text)}? ID
  ;

init_declarator_list
  : member_declarator (Comma member_declarator)*
  ;

member_declarator
  : ((ID)? Colon constant_expression)=>(ID)? Colon constant_expression
  | declarator
    ( (Assign OctalLiteral SemiColon)=> Assign OctalLiteral  // The value must be zero (for pure virtual)
    | Assign initializer
    | LParen expression_list RParen // member function / method declaration
    )?
  ;

initializer
  : remainder_expression  // assignment_expression
  | LCurly initializer (Comma (initializer)? )* RCurly  // Allows comma at end of list
  ;

declarator
  : (ptr_operator)=> ptr_operator declarator // Ampersand or Star etc.
  | direct_declarator
  ;

direct_declarator
  :  
    (qualified_id LParen (RParen|declaration_specifiers) )=>  // Must be function declaration
	  qualified_id  
	  {
	    _p.declaratorID($qualified_id.name, _p.typeDef ? QualifiedItem.Type : QualifiedItem.Fun);
	  }
	  LParen {_p.declaratorParameterList();}
	  parameter_list?
	  RParen {_p.declaratorEndParameterList(false);}
	  type_qualifier*
	  exception_specification?
  |  
    (qualified_id LParen qualified_id)=>  // Must be class instantiation
    qualified_id
    {
      _p.declaratorID($qualified_id.name, QualifiedItem.Var);
    }
    LParen expression_list RParen
  |
    (qualified_id LSquare)=>  // Must be array declaration
    qualified_id
    {
      _p.declaratorID($qualified_id.name, _p.typeDef ? QualifiedItem.Type : QualifiedItem.Var);
      _p.isAddress = false; 
      _p.isPointer = false;
    }
    (LSquare (constant_expression)? RSquare)+ {_p.declaratorArray();}
  |
    (qualified_id RParen LParen)=>  // Must be function declaration (see function_direct_declarator)
    qualified_id
    {
      _p.declaratorID($qualified_id.name, _p.typeDef ? QualifiedItem.Type : QualifiedItem.Fun);
      _p.isAddress = false; 
      _p.isPointer = false;
    }
  |
    qualified_id
    {
      _p.declaratorID($qualified_id.name, _p.typeDef ? QualifiedItem.Type : QualifiedItem.Var);
      _p.isAddress = false; 
      _p.isPointer = false;
    }
  |  
    LParen declarator RParen 
    declarator_suffix? // DW 1/9/04 declarator_suffix made optional as failed on line 2956 in metrics.i
  ;          // According to the grammar a declarator_suffix is not required here

declarator_suffix    // Note: Only used above in direct_declarator
  :
    (LSquare (constant_expression)? RSquare)+
    {_p.declaratorArray();}
  |  
    {  input.LA(1) != LParen 
    || input.LA(2) != ID
    || _p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor, 1) 
    }?
    LParen {_p.declaratorParameterList();}
    parameter_list?
    RParen {_p.declaratorEndParameterList(false);}
    type_qualifier*
    exception_specification?
  ;


conversion_function_decl_or_def
  : Operator declaration_specifiers (Star | Ampersand)?  // DW 01/08/03 Use type_specifier here? see syntax
    ( LessThan template_parameter_list GreaterThan /*{wasInTemplate=False;}*/ )?
    LParen parameter_list? RParen
    type_qualifier*  // DW 29/07/05 ? changed to *
    exception_specification?
    (compound_statement | SemiColon)
  ;

function_declarator [boolean definition]
  : (ptr_operator)=> ptr_operator function_declarator[$definition]
  | function_direct_declarator[$definition]
  ;

function_direct_declarator [boolean definition] 
  :
    (  // fix prompted by (isdigit)() in xlocnum
      LParen declarator RParen
    | 
      qualified_id  {_p.declaratorID($qualified_id.name, QualifiedItem.Fun);}
    )

    LParen 
    {_p.inParameterList = !_p.KandR; _p.functionParameterList();}
    parameter_list? 
    {_p.inParameterList = _p.KandR;}
    RParen
    type_qualifier*
    (Assign OctalLiteral)?  // The value of the octal must be 0
    {_p.functionEndParameterList($definition);}
    exception_specification?
  ;






/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

ctor_definition 
  : ctor_head ctor_body {_p.endConstructorDefinition();}
  ;

ctor_head 
  : ctor_decl_spec ctor_declarator[true]
  ;

ctor_decl_spec
  : (Inline|Explicit)*
  ;

ctor_declarator[boolean definition]
  : qualified_ctor_id
    {_p.declaratorParameterList();}
    LParen parameter_list? RParen
    {_p.declaratorEndParameterList($definition);}
    exception_specification?
  ;


// This matches a generic qualified identifier ::T::B::foo
// that is satisfactory for a ctor (no operator, no trailing <>)
qualified_ctor_id returns [String name]
  : scope_override ID // DW 24/05/04 Note. Neither Ctor or Dtor recorded in dictionary
    {$name = $scope_override.val + $ID.text;} 
    //System.out.printf("CPP_parser.g qualified_ctor_id q \\%s",q);
  ;

ctor_body
  : ctor_initializer? compound_statement
  ;

ctor_initializer
  : Colon superclass_init (Comma superclass_init)*
  ;

superclass_init
  : qualified_id LParen expression_list? RParen
  ;

dtor_head[boolean definition]
  : dtor_decl_spec dtor_declarator[$definition]
  ;

dtor_decl_spec
  : (Inline|Virtual)*
  ;

dtor_declarator[boolean definition]
  : scope_override
    Tilde ID
    {_p.declaratorParameterList();}
    LParen Void? RParen
    {_p.declaratorEndParameterList($definition);}
    exception_specification?
  ;

dtor_body
  : compound_statement {_p.endDestructorDefinition();}
  ;

parameter_list
  : parameter_declaration_list Ellipsis?
  ;

parameter_declaration_list
  : parameter_declaration (Comma parameter_declaration)*
  ;

//See also template_parameter_declaration 
parameter_declaration
  :  
    {_p.beginParameterDeclaration();}
    (
      { !(input.LA(1) == Scope && (input.LA(2) == Star || input.LA(2) == Operator))
      && (input.LA(1) != Scope && input.LA(1) != ID || _p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor) )
      }?
      declaration_specifiers  // DW 24/3/98 Mods for K & R
      (  
        (declarator)=> declarator        // if arg name given
      | 
        abstract_declarator     // if arg name not given  // can be empty
      )
    |
      (declarator)=> declarator      // DW 24/3/98 Mods for K & R
    |
      Ellipsis
    )
    (Assign remainder_expression)? // DW 18/4/01 assignment_expression
  ;

type_id
  : declaration_specifiers abstract_declarator
  ;

// This rule looks a bit weird because (...) can happen in two
// places within the declaration such as "void (*)()" (ptr to
// function returning nothing).  However, the () of a function
// can only occur after having seen either a (abstract_declarator)
// and not after a [..] or simple '*'.  These are the only two
// valid () func-groups:
//    int (*)();     // ptr to func
//    int (*[])();   // array of ptr to func
abstract_declarator
  : ptr_operator abstract_declarator 
  | (LParen abstract_declarator RParen (LSquare|LParen) )=> 
     LParen abstract_declarator RParen abstract_declarator_suffix
  | abstract_declarator_suffix?
  ;

abstract_declarator_suffix
  : (LSquare (constant_expression)? RSquare)+ {_p.declaratorArray();}
  | LParen
    {_p.declaratorParameterList();}
    parameter_list?
    RParen
    {_p.declaratorEndParameterList(false);}
    cv_qualifier_seq
    exception_specification?
  ;

exception_specification
  : Throw 
    LParen 
    (  (scope_override ID (Comma scope_override ID)* )? 
    |  Ellipsis
    )
    RParen
  ;

template_head
  : Template LessThan template_parameter_list GreaterThan
  ;

template_parameter_list
  : {_p.beginTemplateParameterList();}
    template_parameter (Comma template_parameter)*
    {_p.endTemplateParameterList();}
  ;

// Rule requires >2 lookahead tokens. The ambiguity is resolved 
// correctly, however. According to the manual "...A template argument
// that can be interpreted either as a parameter-declaration or a
// type-argument (because its identifier is the name of an
// already existing class) is taken as type-argument."
// Therefore, any "class ID" that is seen on the input, should
// match the first alternative here (it should be a type-argument).
template_parameter
  : type_parameter
  | (parameter_declaration)=> parameter_declaration
  | template_parameter_declaration
  ;

type_parameter
  : (Class|TypeName) (id=ID {_p.templateTypeParameter($id.text);} (Assign assigned_type_name)? )?
  | template_head Class (id2=ID {_p.templateTypeParameter($id2.text);} (Assign assigned_type_name)? )?
  ;

// This is to allow an assigned type_name in a template parameter
// list to be defined previously in the same parameter list,
// as type setting is ineffective whilst guessing
assigned_type_name
  : qualified_type abstract_declarator  
  | type_specifier abstract_declarator
  ;

//See also parameter_declaration
template_parameter_declaration
  :  
    {_p.beginParameterDeclaration();}
    (
      { !(input.LA(1) == Scope && (input.LA(2) == Star || input.LA(2) == Operator))
      && (input.LA(1) != Scope && input.LA(1) != ID || _p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor) )
      }?
      declaration_specifiers  // DW 24/3/98 Mods for K & R
      (  
        (declarator)=> declarator        // if arg name given
      | 
        abstract_declarator     // if arg name not given  // can be empty
      )
    |
      (declarator)=> declarator      // DW 24/3/98 Mods for K & R
    |
      Ellipsis
    )
    (Assign
     additive_expression  // DW 04/09/07 because of ambiguity of ">"
    )?
  ;

// This rule refers to an instance of a template class or function
template_id  // aka template_class_name
  : ID LessThan template_argument_list GreaterThan
  ;

template_argument_list
  : template_argument (Comma template_argument)*
  ;

// Here assignment_expression was changed to shift_expression to rule out
//  x< 1<2 > which causes ambiguities. As a result, these can be used only
//  by enclosing parentheses x<(1<2)>. This is true for x<1+2> ==> bad,
//  x<(1+2)> ==> ok.
template_argument
  :
    // DW 07/04/05 This predicate only used here if next is Scope or ID
    {  input.LA(1) != Scope && input.LA(1) != ID 
    || _p.itemIs(QualifiedItem.Type|QualifiedItem.Ctor)
    }?
    type_id
  |
    shift_expression // failed in iosfwd
  ;



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//////////////////////////////  STATEMENTS ////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

statement_list
  : statement+
  ;

statement
@init {
    _p.lineNo = input.LT(1).getLine();
}
  : (Namespace|Using)=> block_declaration
  | (TypeDef? class_specifier qualified_id? LCurly)=> member_declaration
  | (declaration_specifiers ((ptr_operator)=>ptr_operator)? qualified_id)=> member_declaration
  | (labeled_statement)=> labeled_statement
  | case_statement
  | default_statement
  | expression SemiColon
  | compound_statement
  | selection_statement
  | iteration_statement
  | jump_statement
  | SemiColon
  | try_block
  | throw_statement
  ;
/**
    // The next two entries may be used for debugging
    // Use this statement in the source code to turn antlr trace on (See note above)
  |  'antlrTrace_on' {antlrTrace(True);}
    // Use this statement in the source code to turn antlr trace off (See note above)
  |  'antlrTrace_off' {antlrTrace(False);}
  ;
***/

block_declaration
  : simple_declaration
  | namespace_alias_definition
  | using_statement
  ;

simple_declaration
  : declaration_specifiers init_declarator_list? SemiColon
  ;

labeled_statement
  : ID Colon statement
  ;

case_statement
  : Case constant_expression Colon statement
  ;

default_statement
  : Default Colon statement
  ;

compound_statement
  : LCurly 
    {_p.enterNewLocalScope();}
    statement_list?
    RCurly 
    {_p.exitLocalScope();}
  ;

// NOTE: cannot remove Else ambiguity, but it parses correctly.
// The warning is removed with the options statement
selection_statement
  : If LParen 
    {_p.enterNewLocalScope();}
    condition RParen statement (Else statement)?
    {_p.exitLocalScope();}
  |  
    Switch LParen
    {_p.enterNewLocalScope();}
    condition RParen statement
    {_p.exitLocalScope();}
  ;

iteration_statement
  :  
    While  LParen
    {_p.enterNewLocalScope();}
    condition RParen statement  
    {_p.exitLocalScope();}
  |  
    Do 
    {_p.enterNewLocalScope();}
    statement While
    LParen expression RParen 
    {_p.exitLocalScope();}
    SemiColon 
  |  
    For LParen
    {_p.enterNewLocalScope();}
    (  (declaration)=> declaration 
    |  expression? SemiColon
    )
    condition? SemiColon
    expression?
    RParen statement   
    {_p.exitLocalScope();}
  ;

condition
  : (declaration_specifiers declarator Assign)=> 
     declaration_specifiers declarator Assign remainder_expression
  |  expression
  ;

jump_statement
  :  
    (  Goto ID SemiColon
    |  Continue SemiColon
    |  Break SemiColon
    |  Return {_p.inReturn = true;}
       (
         // DW 16/05/03 May be problem here if return is followed by a cast expression 
         // This is an unsatisfactory fix for problem in xstring re 'return (allocator);'
         //  and in xlocale re return (_E)(_Tolower((unsigned char)_C, &_Ctype));
         (LParen {_p.itemIs(QualifiedItem.Type)}? ID RParen)=> LParen ID RParen expression?  
       |  expression 
       )?  
       SemiColon {_p.inReturn = false;} 
    )
  ;

try_block
  : Try compound_statement handler*
  ;

handler
  : Catch
    {_p.exceptionBeginHandler();}
    {_p.declaratorParameterList();}
    LParen exception_declaration RParen
    {_p.declaratorEndParameterList(true);}
    compound_statement
    {_p.exceptionEndHandler();}
  ;

exception_declaration
  : parameter_declaration_list
  ;

// This is an expression of type void according to the ARM, which
// to me means "statement"; it removes some ambiguity to put it in
// as a statement also.
throw_statement
  : Throw assignment_expression? SemiColon
  ;

using_statement
  : Using
    ( Namespace qualified_id    // Using-directive
    | TypeName? qualified_id  // Using-declaration
    )
    SemiColon
  ;


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//////////////////////////////  EXPRESSIONS ///////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

// Same as expression_list
expression
@init {
    _p.lineNo = input.LT(1).getLine();
}
  : assignment_expression (Comma assignment_expression)*
  ;

// right-to-left for assignment op
assignment_expression
  : conditional_expression
    (
      (Assign
      |TimesAssign
      |DivideAssign
      |MinusAssign
      |PlusAssign
      |ModAssign
      |ShiftLeftAssign
      |ShiftRightAssign
      |BitwiseAndAssign
      |BitwiseExOrAssign
      |BitwiseOrAssign
      )
      remainder_expression
    )?
  ;

remainder_expression
  : (conditional_expression (Comma|SemiColon|RParen) )=>
      {_p.assignStmtRHSFound += 1;}
      assignment_expression
      {
      if (_p.assignStmtRHSFound > 0)
        _p.assignStmtRHSFound -= 1;
      else
        _debug("warning Error in assignStmtRHSFound = \%s", _p.assignStmtRHSFound);
      }
  |  
    assignment_expression
  ;

conditional_expression
  : logical_or_expression (QuestionMark expression Colon conditional_expression)?
  ;

constant_expression
  : conditional_expression
  ;

logical_or_expression
  : logical_and_expression (Or logical_and_expression)* 
  ;

logical_and_expression
  : inclusive_or_expression (And inclusive_or_expression)* 
  ;

inclusive_or_expression
  : exclusive_or_expression (BitwiseOr exclusive_or_expression)*
  ;

exclusive_or_expression
  : and_expression (BitwiseExOr and_expression)*
  ;

and_expression
  : equality_expression (Ampersand equality_expression)*
  ;

equality_expression
  : relational_expression ( (NotEquals|Equals) relational_expression)*
  ;

relational_expression
  : shift_expression
    (
      options{backtrack=true;}: //added by V3-Author //options {warnWhenFollowAmbig = false;}:
      //{!wasInTemplate}?
      (LessThan|GreaterThan|LessThanOrEquals|GreaterThanOrEquals)
      shift_expression
    )?
  ;

shift_expression
  : additive_expression ((ShiftLeft|ShiftRight) additive_expression)*
  ;

// See comment for multiplicative_expression regarding #pragma
additive_expression
  :  
    multiplicative_expression
    (//options{backtrack=true;k=3;}: //added by V3-Author //{dummyVar}? //added by V3-Author //options{warnWhenFollowAmbig = false;}:
      (Plus | Minus) multiplicative_expression
    )*
  ;

// ANTLR has trouble dealing with the analysis of the confusing unary/binary
// operators such as Star, Ampersand, Plus, etc...  
// With the #pragma (now "(options{warnWhenFollowAmbig = false;}:" etc.)
// we simply tell ANTLR to use the "quick-to-analyze" approximate lookahead
// as full LL(k) lookahead will not resolve the ambiguity anyway.  Might
// as well not bother.  This has the side-benefit that ANTLR doesn't go
// off to lunch here (take infinite time to read grammar).
multiplicative_expression
  : pm_expression
    (//options{backtrack=true;k=3;}: //added by V3-Author //{dummyVar}? //added by V3-Author //options{warnWhenFollowAmbig = false;}:
      (Star|Divide|Mod) pm_expression
    )*
  ;

pm_expression
  : cast_expression ( (DotMbr|PointerToMbr) cast_expression)*
  ;

// The string "( ID" can be either the start of a cast or
///the start of a unary_expression.  However, the ID must
// be a type name for it to be a cast.  Since ANTLR can only hoist
// semantic predicates that are visible without consuming a token,
// the semantic predicate in rule type_name is not hoisted--hence, the
// rule is reported to be ambiguous.  I am manually putting in the
// correctly hoisted predicate.
//
// Ack! Actually "( ID" might be the start of "(T(expr))" which makes
// the first parens just an ordinary expression grouping.  The solution
// is to look at what follows the type, T.  Note, this could be a
// qualified type.  Yucko.  I believe that "(T(" can only imply
// function-style type cast in an expression (...) grouping.
//
// We DO NOT handle the following situation correctly at the moment:
// Suppose you have
//    struct rusage rusage;
//    return (rusage.fp);
//    return (rusage*)p;
// Now essentially there is an ambiguity here. If rusage is followed by any
// postix operators then it is an identifier else it is a type name. This
// problem does not occur in C because, unless the tag struct is attached,
// rusage is not a type name. However in C++ that restriction is removed.
// No *real* programmer would do this, but it's in the C++ standard just for
// fun..
//
// Another fun one (from an LL standpoint):
//
//   (A::B::T *)v;      // that's a cast of v to type A::B::T
//   (A::B::foo);    // that's a simple member access
//
// The qualifiedItemIs(1) function scans ahead to what follows the
// final "::" and returns qiType if the item is a type.  The offset of
// '1' makes it ignore the initial LParen; normally, the offset is 0.
cast_expression 
  : (LParen type_id RParen unary_expression)=>   LParen type_id RParen unary_expression
  | (LParen type_id RParen cast_expression)=>    LParen type_id RParen cast_expression
  | unary_expression  // handles outer (...) of "(T(expr))"
  ;

unary_expression
  : (postfix_expression)=>   postfix_expression
  | Increment unary_expression
  | Decrement unary_expression
  | unary_operator cast_expression
  | SizeOf 
    ( 
      (unary_expression)=> unary_expression 
    | 
      LParen type_id RParen  
    )
  | Scope? (new_expression | delete_expression)
  ;


postfix_expression
  :
    // Function-style cast must have a leading type
    {input.LA(1) != LParen}?
    (type_specifier LParen RParen LParen)=>  // DW 01/08/03 To cope with problem in xtree (see test10.i) 
     type_specifier LParen RParen LParen expression_list? RParen 
  |
    {input.LA(1) != LParen}? =>
    (type_specifier LParen)=>
     type_specifier LParen expression_list? RParen 
    // Following put in to allow for the above being a constructor 
    // as shown in test_constructors_destructors.cpp
    (Dot postfix_expression)?
  |
    primary_expression
    (  LSquare expression RSquare
    |  LParen expression_list? RParen // function call/function-call or method call/method-call.
    |  (Dot|PointerTo) Template? id_expression
    |  Increment 
    |  Decrement
    )*
  |
    Cast
    LessThan Const? type_specifier ptr_operator? GreaterThan
    LParen expression RParen
  |
    TypeID 
    LParen ((type_id)=>type_id|expression) RParen
    ( (Dot|PointerTo) postfix_expression)?
  ;

primary_expression
  : id_expression
  | literal
  | This
  | LParen expression RParen
  ;

id_expression 
  : qualified_id 
  ;

literal
  : True
  | False
  | HexLiteral
  | OctalLiteral
  | DecimalLiteral
  | CharacterLiteral
  | FloatingPointLiteral
  | StringLiteral+
  ;

unary_operator
  : Ampersand
  | Star
  | Plus
  | Minus
  | Tilde
  | Not
  ;


// JEL The first ()? is used to resolve "new (expr) (type)" because both
// (expr) and (type) look identical until you've seen the whole thing.
//
// new_initializer appears to be conflicting with function arguments as
// function arguments can follow a primary_expression.  [This is a full
// LL(k) versus LALL(k) problem.  Enhancing context by duplication of
// some rules might handle this.]
new_expression
  : New
    ( (LParen expression_list RParen)=>     LParen expression_list RParen )?
    ( 
      (LParen type_id RParen)=>   LParen type_id RParen  
    | 
      new_type_id 
    )
    ( (new_initializer)=>                   new_initializer )?
  ;

new_initializer
  :  LParen expression_list? RParen
  ;

new_type_id
  :  declaration_specifiers new_declarator?
  ;

new_declarator
  :  ptr_operator new_declarator?
  |  direct_new_declarator
  ;

// The "[expression]" construct conflicts with the "new []" construct
// (and possibly others).  We used approximate lookahead for the "new []"
// construct so that it would not try to compute full LL(2) lookahead.
// Here, we use #pragma approx again because anytime we see a [ followed
// by token that can begin an expression, we always want to loop.
// Approximate lookahead handles this correctly.  In fact, approximate
// lookahead is the same as full lookahead when all but the last lookahead
// depth are singleton sets; e.g., {"["} followed by FIRST(expression).
direct_new_declarator
  : (LSquare expression RSquare)+
  ;


ptr_operator 
  : Ampersand   {_p.isAddress = true;} 
  | ('_cdecl'|'__cdecl') 
  | ('_near'|'__near') 
  | ('_far'|'__far') 
  | '__interrupt' 
  | ('pascal'|'_pascal'|'__pascal') 
  | ('_stdcall'|'__stdcall') 
  | (scope_override Star cv_qualifier_seq)=>  scope_override Star {_p.isPointer = true;} cv_qualifier_seq
  ;
   
  

// Match A::B::*  // May be redundant 14/06/06
ptr_to_member  // Part of ptr_operator in grammar.txt
  : scope_override Star  {_p.isPointer = true;} cv_qualifier_seq
  ;

// JEL note:  does not use (const|volatile)* to avoid lookahead problems
cv_qualifier_seq
  : type_qualifier*
  ;


// Match "(::)A::B::C::(template)" or just "::"
scope_override returns [String val]
@init {
    StringBuilder sb = new StringBuilder();
}
@after {
    $val = sb.toString();
}
  :
    (Scope {sb.append("::");} )?
    (
      (ID LessThan template_argument_list GreaterThan Scope)=>
	      id1=ID {sb.append($id1.text);}
	      LessThan template_argument_list GreaterThan
	      Scope {sb.append("::");}
	      (Template {sb.append("template");})?
    |  
      (ID Scope)=> // added by V3-Author
	      id2=ID {sb.append($id2.text);}
	      Scope {sb.append("::");}
	      (Template {sb.append("template");})?
    )*
  ;



delete_expression
  : Class (LSquare RSquare)? cast_expression
  ;

// Same as expression
expression_list
  : assignment_expression (Comma assignment_expression)*
  ;

// NOTE: you may need to add backtracking depending on the C++ standard specifications used...
// but for now V3-Author has decided not to add that and go for the default alternative 1 selected
// during antlr code generation...
optor returns [String val]
  : New                          {$val = " new";} 
             ( LSquare RSquare   {$val += "[]";} )?
  | Delete                       {$val = " delete";} 
             ( LSquare RSquare   {$val += "[]";} )?
  | LParen RParen                {$val = "()";}
  | LSquare RSquare              {$val = "[]";}
  | optor_simple_tokclass        {$val = $optor_simple_tokclass.text;}
  | type_specifier LParen RParen {$val = "type-specifier()";}
  ;


optor_simple_tokclass
  : Plus
  | Minus
  | Star
  | Divide
  | Mod
  | BitwiseExOr
  | Ampersand
  | BitwiseOr
  | Tilde
  | Not
  | ShiftLeft
  | ShiftRight
  | Assign
  | TimesAssign
  | DivideAssign
  | ModAssign
  | PlusAssign
  | MinusAssign
  | ShiftLeftAssign
  | ShiftRightAssign
  | BitwiseAndAssign
  | BitwiseExOrAssign
  | BitwiseOrAssign
  | Equals
  | NotEquals
  | LessThan
  | GreaterThan
  | LessThanOrEquals
  | GreaterThanOrEquals
  | Or
  | And
  | Increment
  | Decrement
  | Comma
  | PointerTo
  | PointerToMbr
  ;


/////////////////////////////////////////////////////////////

// Operators:

Assign             : '=' ;
Colon              : ':' ;
Comma              : ',' ;
QuestionMark       : '?' ;
SemiColon          : ';' ;
PointerTo          : '->' ;

// Dot & Ellipsis are commented out since they are generated as part of
// the Number rule below due to some bizarre lexical ambiguity shme.
Dot                : '.' ;
Ellipsis           : '...' ;

LParen             : '(' ;
RParen             : ')' ;
LSquare            : '[' ;
RSquare            : ']' ;
LCurly             : '{' ;
RCurly             : '}' ;

Equals             : '==' ;
NotEquals          : '!=' ;
LessThanOrEquals   : '<=' ;
LessThan           : '<' ;
GreaterThanOrEquals: '>=' ;
GreaterThan        : '>' ;

Divide             : '/' ;
DivideAssign       : '/=' ;
Plus               : '+' ;
PlusAssign         : '+=' ;
Increment          : '++' ;
Minus              : '-' ;
MinusAssign        : '-=' ;
Decrement          : '--' ;
Star               : '*' ;
TimesAssign        : '*=' ;
Mod                : '%' ;
ModAssign          : '%=' ;
ShiftRight         : '>>' ;
ShiftRightAssign   : '>>=' ;
ShiftLeft          : '<<' ;
ShiftLeftAssign    : '<<=' ;

And                : '&&' ;
Not                : '!' ;
Or                 : '||' ;

Ampersand          : '&' ;
BitwiseAndAssign   : '&=' ;
Tilde              : '~' ;
BitwiseOr          : '|' ;
BitwiseOrAssign    : '|=' ;
BitwiseExOr        : '^' ;
BitwiseExOrAssign  : '^=' ;

//Zuo: the following tokens are come from cplusplus.g

PointerToMbr       : '->*' ;
DotMbr             : '.*'  ;

Scope              : '::'  ;

// Keywords
Auto               : 'auto'            ;
Bool               : 'bool'            ;
Break              : 'break'           ;
Case               : 'case'            ;
Cast               : 'dynamic_cast'|'static_cast'|'reinterpret_cast'|'const_cast';
Catch              : 'catch'           ;
Char               : 'char'            ;
Class              : 'class'           ;
Const              : 'const'|'__const' ;
Continue           : 'continue'        ;
DeclSpec           : '_declspec'|'__declspec'      ; // microsoft specific
Default            : 'default'         ;
Delete             : 'delete'          ;
Do                 : 'do'              ;
Double             : 'double'          ;
Else               : 'else'            ;
Enum               : 'enum'            ;
Extern             : 'extern'          ;
Explicit           : 'explicit'        ;
Extension          : '__extension__' {$channel=HIDDEN;}; // GNU specific
False              : 'false'           ;
Float              : 'float'           ;
For                : 'for'             ;
Friend             : 'friend'          ;
Goto               : 'goto'            ;
If                 : 'if'              ;
Int                : 'int'|'_int8'|'__int8'|'_int16'|'__int16';
Inline             : 'inline'|'_inline'|'__inline__'|'__inline';
Long               : 'long'|'_int32'|'__int32'|'_int64'|'__int64'|'_w64'|'__w64';
Mutable            : 'mutable'         ;
Namespace          : 'namespace'       ;
New                : 'new'             ;
Operator           : 'operator'        ;
Public             : 'public'          ;
Protected          : 'protected'       ;
Private            : 'private'         ;
Register           : 'register'        ;
Restrict           : ('restrict'|'__restrict'|'__restrict__') {$channel=HIDDEN;};
Return             : 'return'          ;
Short              : 'short'           ;
Signed             : 'signed'          ;
SizeOf             : 'sizeof'|'__alignof__';
Static             : 'static'          ;
Struct             : 'struct'          ;
Switch             : 'switch'          ;
Template           : 'template'        ;
This               : 'this'            ;
Throw              : 'throw'           ;
True               : 'true'            ;
Try                : 'try'             ;
TypeDef            : 'typedef'         ;
TypeID             : 'typeid'          ;
TypeName           : 'typename'        ;
Union              : 'union'           ;
Unsigned           : 'unsigned'        ;
Using              : 'using'           ;
Virtual            : 'virtual'         ;
Void               : 'void'            ;
Volatile           : 'volatile'        ;
WChar_T            : 'wchar_t'         ;
While              : 'while'           ;
/////////

// complex tokens
ID
  : Letter (Letter|'0'..'9')*
  ;

fragment Asm                : 'asm'|'__asm__'|'__asm';
InlineAssembly
  : Asm Volatile?
      LParen
          StringLiteral+ (Colon (StringLiteral (LParen ID RParen)? Comma?)* )* 
      RParen
    {$channel = HIDDEN;}
  ;

fragment Attribute          : '__attribute__'   ; // GNU specific
AttributeSpecifier
  : Attribute LParen LParen (~RParen)* RParen RParen {$channel = HIDDEN;}
  ;


fragment
Letter
  : '$'
  | 'A'..'Z'
  | 'a'..'z'
  | '_'
  ;

CharacterLiteral
  : 'L'? '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
  ;

StringLiteral
  : 'L'? '"' ( EscapeSequence | ~('\\'|'"') )* '"'
  ;

HexLiteral 
  : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? 
  ;

DecimalLiteral 
  : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? 
  ;

OctalLiteral 
  : '0' ('0'..'7')+ IntegerTypeSuffix? 
  ;

fragment
HexDigit 
  : ('0'..'9'|'a'..'f'|'A'..'F') 
  ;

fragment
IntegerTypeSuffix
  : ('u'|'U')  ('l'|'L')
  | ('u'|'U')
  | ('l'|'L') ('l'|'L')?
  ;

FloatingPointLiteral
  : ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
  | '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
  | ('0'..'9')+ Exponent FloatTypeSuffix
  | ('0'..'9')+ Exponent
  | ('0'..'9')+ FloatTypeSuffix
  ;

fragment
Exponent 
  : ('e'|'E') ('+'|'-')? ('0'..'9')+ 
  ;

fragment
FloatTypeSuffix 
  : ('f'|'F'|'d'|'D') 
  ;

fragment
EscapeSequence
  : '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
  | OctalEscape
  ;

fragment
OctalEscape
  : '\\' ('0'..'3') ('0'..'7') ('0'..'7')
  | '\\' ('0'..'7') ('0'..'7')
  | '\\' ('0'..'7')
  ;

fragment
UnicodeEscape
  : '\\' 'u' HexDigit HexDigit HexDigit HexDigit
  | '\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
  ;
  
WS: (' '|'\r'|'\t'|'\u000C'|'\n')+ {$channel=HIDDEN;}
  ;

Comment
  : '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;}
  ;

LineComment
  : '//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
  ;

PreProcessorCommand 
  : '#' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN; recordHeader($line, $text);}
  ;




